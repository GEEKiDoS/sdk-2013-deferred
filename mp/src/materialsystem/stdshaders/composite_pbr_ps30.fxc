//==================================================================================================
//
// Physically Based Rendering pixel shader for brushes and models
//
//==================================================================================================

// STATIC: "LIGHTMAPPED"                "0..1"
// STATIC: "USEENVAMBIENT"              "0..1"
// STATIC: "EMISSIVE"                   "0..1"
// STATIC: "PARALLAXOCCLUSION"			"0..1"
// STATIC: "BUMPED"						"0..1"

// DYNAMIC: "WRITEWATERFOGTODESTALPHA"  "0..1"
// DYNAMIC: "PIXELFOGTYPE"              "0..1"
// DYNAMIC: "WRITE_DEPTH_TO_DESTALPHA"  "0..1"
// DYNAMIC: "STATIC_LIGHT_LIGHTMAP"		"0..1"
// DYNAMIC: "STATIC_LIGHT_VERTEX"		"0..1"
// DYNAMIC: "ENABLE_SPECULAR"			"0..1"

// Can't write fog to alpha if there is no fog
// SKIP: ($PIXELFOGTYPE == 0) && ($WRITEWATERFOGTODESTALPHA != 0)

#define SPECULAR 1

#if defined(__INTELLISENSE__)
#define LIGHTMAPPED 1
#endif

#include "common_ps_fxc.h"
#include "common_lightmappedgeneric_fxc.h"
#include "common_vertexlitgeneric_dx9.h"

#include "pbr_common_ps2_3_x.h"

// constants
const float4 g_DiffuseModulation : register(c1);
const float4 g_EyePos : register(c2);
const float4 g_FogParams : register(c3);
const float4 g_BaseColor : register(c4);
const float4 g_sunColor : register(c5);
#if PARALLAXOCCLUSION
const float4 g_ParallaxParms : register( c6 );
#define PARALLAX_DEPTH g_ParallaxParms.r
#define PARALLAX_CENTER g_ParallaxParms.g
#endif
const float2 g_vecFullScreenTexel : register(c7);
const float3 cAmbientCube[6] : register(c8);

// samplers
// Base map, selfillum in alpha
sampler BaseTextureSampler : register(s0);
// Normal map
sampler NormalTextureSampler : register(s1);
// Cubemap
sampler EnvmapSampler : register(s2);
// LightAccum Sampler, Sun Light in alpha
sampler LightAccumSampler : register(s3);
// Lightmap
sampler LightmapSampler : register(s4);
// MRAO texture
sampler MRAOTextureSampler : register(s5);
#if EMISSIVE
// Emission texture
sampler EmissionTextureSampler : register(s6);    
#endif
sampler SpecRoughSampler : register(s7);

#define ENVMAPLOD (g_EyePos.a)

struct PS_INPUT
{
	float2 baseTexCoord : TEXCOORD0;
	float3 worldNormal : TEXCOORD1;
	float3 worldPos : TEXCOORD2;
	float3 projPos : TEXCOORD3;
	float4 lightmapTexCoord0And1 : TEXCOORD4;
	float4 lightmapTexCoord2And3 : TEXCOORD5;
	float3 staticLighting : TEXCOORD6;
	float2 screenPos : VPOS;
};

// Entry point
float4 main(PS_INPUT i) : COLOR
{
	float2 screenPos = (i.screenPos + 0.5f) * g_vecFullScreenTexel;
	
#if USEENVAMBIENT
    float3 EnvAmbientCube[6];
    setupEnvMapAmbientCube(EnvAmbientCube, EnvmapSampler);
#else
#define EnvAmbientCube cAmbientCube
#endif

	float3 surfNormal = normalize(i.worldNormal);
	float3 surfTangent;
	float3 surfBase;
	float flipSign;
	float3x3 normalBasis = compute_tangent_frame(surfNormal, i.worldPos, i.baseTexCoord, surfTangent, surfBase, flipSign);

#if PARALLAXOCCLUSION
    float3 outgoingLightRay = g_EyePos.xyz - i.worldPos;
    float3 outgoingLightDirectionTS = worldToRelative( outgoingLightRay, surfTangent, surfBase, surfNormal);
    float2 correctedTexCoord = parallaxCorrect(i.baseTexCoord, outgoingLightDirectionTS , outgoingLightRay, i.worldNormal, NormalTextureSampler , PARALLAX_DEPTH , PARALLAX_CENTER);
#else
	float2 correctedTexCoord = i.baseTexCoord;
#endif

	float3 textureNormal = normalize((tex2D(NormalTextureSampler, correctedTexCoord).xyz - float3(0.5, 0.5, 0.5)) * 2);
	float3 normal = normalize(mul(textureNormal, normalBasis)); // World Normal

	float4 albedo = tex2D(BaseTextureSampler, correctedTexCoord);
	albedo.xyz *= g_BaseColor.rgb;

	float3 mrao = tex2D(MRAOTextureSampler, correctedTexCoord).xyz;
	float ambientOcclusion = mrao.z;
#if EMISSIVE
    float3 emission = tex2D(EmissionTextureSampler, correctedTexCoord).xyz;
#endif
	float4 specRough = tex2D(SpecRoughSampler, screenPos);
	float roughness = specRough.a;

	textureNormal.y *= flipSign; // Fixup textureNormal for ambient lighting

	float3 outgoingLightDirection = normalize(g_EyePos.xyz - i.worldPos); // Lo
	float lightDirectionAngle = max(0, dot(normal, outgoingLightDirection)); // cosLo

	float3 specularReflectionVector = 2.0 * lightDirectionAngle * normal - outgoingLightDirection; // Lr

	float3 fresnelReflectance = specRough.rgb; // F0

    // Start ambient
	float3 ambientLighting = 0.0;
	
#if LIGHTMAPPED
#if BUMPED
		float4 lightmap1 = tex2D(LightmapSampler, i.lightmapTexCoord0And1.zw);
		float4 lightmap2 = tex2D(LightmapSampler, i.lightmapTexCoord2And3.xy);
		float4 lightmap3 = tex2D(LightmapSampler, i.lightmapTexCoord2And3.zw);
	
		float3 diffuseIrradiance = (
			lightmap1.rgb * textureNormal.x +    
			lightmap2.rgb * textureNormal.y +    
			lightmap3.rgb * textureNormal.z  
		) * g_DiffuseModulation.rgb;
	
		float sunAmount = (
			lightmap1.a * textureNormal.x +
			lightmap2.a * textureNormal.y +
			lightmap3.a * textureNormal.z  
		);
#else
	float4 lightmap = tex2D(LightmapSampler, i.lightmapTexCoord0And1.xy);
	float3 diffuseIrradiance = lightmap.rgb * g_DiffuseModulation.rgb;
	float sunAmount = lightmap.a;
#endif
#else
#if STATIC_LIGHT_LIGHTMAP
		float3 diffuseIrradiance = tex2D(LightmapSampler, i.baseTexCoord) * g_DiffuseModulation.rgb;
#elif STATIC_LIGHT_VERTEX
		float3 diffuseIrradiance = i.staticLighting;
#else
		float3 diffuseIrradiance = PixelShaderAmbientLight(normal, EnvAmbientCube);
#endif
	
	float sunAmount = 1.0;
#endif
	
	//return float4(diffuseIrradiance, 1); // testing diffuse irraciance
	
	float3 ambientLightingFresnelTerm = fresnelSchlickRoughness(fresnelReflectance, lightDirectionAngle, roughness); // F
    float3 diffuseContributionFactor = 1 - ambientLightingFresnelTerm; // kd
	float3 diffuseIBL = diffuseContributionFactor * albedo.rgb * diffuseIrradiance;

#if ENABLE_SPECULAR
	float4 specularUV = float4(specularReflectionVector, roughness * ENVMAPLOD);
	float3 lookupHigh = ENV_MAP_SCALE * texCUBElod(EnvmapSampler, specularUV).xyz;
	float3 lookupLow = PixelShaderAmbientLight(specularReflectionVector, EnvAmbientCube);
	float3 specularIrradiance = lerp(lookupHigh, lookupLow, roughness * roughness);
	float3 specularIBL = specularIrradiance * EnvBRDFApprox(fresnelReflectance, roughness, lightDirectionAngle);
#else
	float3 specularIBL = float3(0, 0, 0);
#endif
	
	ambientLighting = (diffuseIBL + specularIBL) * ambientOcclusion;
    // End ambient

    // Start direct
	float4 lightAccum = tex2D(LightAccumSampler, screenPos);
	float3 directLighting = lightAccum.rgb;
	directLighting += lightAccum.a * sunAmount * g_sunColor.rgb;
	directLighting *= albedo;
    // End direct

	float fogFactor = 0.0f;
	fogFactor = CalcPixelFogFactor(PIXELFOGTYPE, g_FogParams, g_EyePos.z, i.worldPos.z, i.projPos.z);

	float alpha = 0.0f;
#if WRITEWATERFOGTODESTALPHA && (PIXELFOGTYPE == PIXEL_FOG_TYPE_HEIGHT)
    alpha = fogFactor;
#else
	alpha = albedo.a;
#endif

	bool bWriteDepthToAlpha = (WRITE_DEPTH_TO_DESTALPHA != 0) && (WRITEWATERFOGTODESTALPHA == 0);

	float3 combinedLighting = directLighting + ambientLighting;
#if EMISSIVE
    combinedLighting += emission;
#endif
		
	return FinalOutput(float4(combinedLighting, alpha), fogFactor, PIXELFOGTYPE, TONEMAP_SCALE_LINEAR, bWriteDepthToAlpha, i.projPos.z);
}
