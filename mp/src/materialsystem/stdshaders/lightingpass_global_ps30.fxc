
// DYNAMIC:		"HAS_SHADOW"		"0..1"

#include "common_ps_fxc.h"
#include "common_deferred_fxc.h"

#include "common_vertexlitgeneric_dx9.h"
#include "common_lightmappedgeneric_fxc.h"
#define SPECULAR 1
#include "pbr_common_ps2_3_x.h"

sampler sNormals : register(s0);
sampler sDepth : register(s1);
sampler sSpecRough : register(s2);

#if HAS_SHADOW
sampler sShadowDepth						: register( s3 );
#endif

// CommitBaseDeferredConstants_Origin
const float3 g_vecViewOrigin : register(c0);
// CommitGlobalLightForward
const float3 g_vecLightVec_Forward : register(c1);

// CommitShadowProjectionConstants_Ortho_Composite
const float4x3 g_matOrtho[2] : register(c2);
const float4 g_vecUVTransform[2] : register(c8);
const float3 g_vecSlopeData[2] : register(c10);
const float4 g_vecFilterConfig_A[2] : register(c12);
const float4 g_vecFilterConfig_B[2] : register(c14);

const float3 g_light_diffuse : register(c16);

struct PS_INPUT
{
	float2 vTexCoord : TEXCOORD0;
	float3 vecWorldRay : TEXCOORD1;
};

struct PS_OUTPUT
{
	float4 vColor_0 : COLOR0;
};

float Luminance(float3 cColor)
{
	// Formula for calculating luminance based on NTSC standard
	return dot(cColor.rgb, float3(0.2125, 0.7154, 0.0721));
}

PS_OUTPUT main(const PS_INPUT In)
{
	PS_OUTPUT Out = (PS_OUTPUT) 0;

	float3 normal = (tex2D(sNormals, In.vTexCoord).rgb - 0.5f) / 0.5f;
	float depth = tex2D(sDepth, In.vTexCoord).r;
	float3 worldPos = g_vecViewOrigin + In.vecWorldRay * depth;
	
	float4 specularRough = tex2D(sSpecRough, In.vTexCoord);
	float3 fresnelReflectance = specularRough.rgb;
	float roughness = specularRough.a;

	float3 outgoingLightDirection = normalize(g_vecViewOrigin.xyz - worldPos); // Lo
	float lightDirectionAngle = max(0, dot(normal, outgoingLightDirection)); // cosLo

	float3 LightIn = g_vecLightVec_Forward;
	float3 LightColor = float3(1.0, 1.0, 1.0);
	
	float viewFwdDot = dot(g_vecLightVec_Forward.xyz, normal);
	
	float3 directLighting = calculateLight(LightIn, LightColor, outgoingLightDirection,
                    normal, fresnelReflectance, roughness, 0, lightDirectionAngle, 0.5.xxx);
	
#if HAS_SHADOW
	directLighting *= PerformCascadedShadow(sShadowDepth, worldPos, g_matOrtho, g_vecUVTransform, g_vecSlopeData,
									g_vecFilterConfig_A, g_vecFilterConfig_B, normal, viewFwdDot);
#endif
	
	// write direct sunlight in alpha
	Out.vColor_0 = WriteLighting(float4(0, 0, 0, dot(directLighting.xyz, 0.3333.xxx)));

	return Out;
}
