
// STATIC: "BLENDMODULATE"              "0..1"
// STATIC: "LIGHTMAPPED"                "0..1"
// STATIC: "USEENVAMBIENT"              "0..1"
// STATIC: "EMISSIVE"                   "0..1"

#include "common_ps_fxc.h"
#include "common_deferred_fxc.h"
#include "common_lightmappedgeneric_fxc.h"
#include "common_vertexlitgeneric_dx9.h"

#define SPECULAR 1
#include "pbr_common_ps2_3_x.h"

sampler sAlbedo							: register( s0 );
sampler sMrao							: register( s1 );
sampler sNormals						: register( s2 );
sampler sSpecRough						: register( s3 );
sampler sLightAccum						: register( s4 );
sampler sLightmap						: register( s5 );
sampler sEnvmap							: register( s6 );
#if EMISSIVE
sampler sEmissive						: register( s7 );
#endif

const float4 g_EyePos					: register(c1);
const float4 g_DiffuseModulation		: register(c2);
#if USEENVAMBIENT
const float3 cAmbientCube[6]			: register(c3);
#endif

#define ENVMAPLOD (g_EyePos.a)

struct PS_INPUT
{
#if BLENDMODULATE
	float4 vTexCoord				: TEXCOORD0;
#else
	float2 vTexCoord				: TEXCOORD0;
#endif

	//float3 vProjPosXYW				: TEXCOORD1;
	float3 vWorldPos				: TEXCOORD2;
	float4 lightmapTexCoord1And2	: TEXCOORD4;
	float4 lightmapTexCoord3		: TEXCOORD5;

#if BASETEXTURE2
	float4 vColor_0					: COLOR0;
#endif

#if NOCULL
	float vDir						: VFACE;
#endif

	float2 vScreenPos				: VPOS;
};


float4 main( const PS_INPUT In ): COLOR0
{
#if !USEENVAMBIENT
    float3 EnvAmbientCube[6];
	setupEnvMapAmbientCube(EnvAmbientCube, sEnvmap);
#else
    #define EnvAmbientCube cAmbientCube
#endif
	
	float4 albedo = tex2D(sAlbedo, In.vTexCoord);
	float4 specRough = tex2D(sSpecRough, In.vScreenPos);
	float3 specular = specRough.rgb;
	float roughness = specRough.a;
	float3 normal = (tex2D(sNormals, In.vScreenPos) * 2.0) - 1.0;
	float4 mrao = tex2D(sMrao, In.vTexCoord);
	float ambientOcclusion = mrao.b;
	
	float3 outgoingLightDirection = normalize(g_EyePos.xyz - In.vWorldPos); // Lo
	float lightDirectionAngle = max(0, dot(normal, outgoingLightDirection)); // cosLo
	
	float3 specularReflectionVector = 2.0 * lightDirectionAngle * normal - outgoingLightDirection; // Lr
	
	float3 directLighting = tex2D(sLightAccum, In.vScreenPos);
	float3 diffuseIrradiance = 
		ambientLookup(normal, EnvAmbientCube, float3(0.5, 0.5, 1.0), In.lightmapTexCoord1And2, In.lightmapTexCoord3, sLightmap, g_DiffuseModulation);
	float3 ambientLightingFresnelTerm = fresnelSchlickRoughness(specular, lightDirectionAngle, roughness); // F
	float3 diffuseContributionFactor = 1 - ambientLightingFresnelTerm; // kd
	float3 diffuseIBL = diffuseContributionFactor * albedo.rgb * diffuseIrradiance;

	float4 specularUV = float4(specularReflectionVector, roughness * ENVMAPLOD);
	float3 lookupHigh = ENV_MAP_SCALE * texCUBElod(sEnvmap, specularUV).xyz;
	float3 lookupLow = PixelShaderAmbientLight(specularReflectionVector, EnvAmbientCube);
	float3 specularIrradiance = lerp(lookupHigh, lookupLow, roughness * roughness);
	float3 specularIBL = specularIrradiance * EnvBRDFApprox(specular, roughness, lightDirectionAngle);
	
	float3 ambientLighting = (diffuseIBL + specularIBL) * ambientOcclusion;
	
	float3 combinedLighting = directLighting + ambientLighting;
#if EMISSIVE
	float3 emission = tex2D(sEmissive, In.vTexCoord);
	combinedLighting += emission;
#endif

	return float4(combinedLighting, 1.0);
}
